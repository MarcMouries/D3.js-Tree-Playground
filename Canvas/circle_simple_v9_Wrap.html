<!DOCTYPE html>
<html>

<head>
	<script type="text/javascript" src="trigo.js"></script>
	<script type="text/javascript" src="links_icons.js"></script>
	<script type="text/javascript" src="image_utils.js"></script>
	<script type="text/javascript" src="MCanvas.js"></script>
</head>

<style type="text/css">
	:root {
		--radius: 3px;
		--small: 0.5em;
		--medium: 1em;
		--large: 1.5em;
		--shadow: 0 1px 2px rgba(16, 10, 9, 0.15);
		--gray-400: #d3d0c9;
	}

	#chart_container {
		width: 100%;
		height: 100%;
		background: white;
	}

	#chart_container_OLD {
		position: fixed;
		width: 1200px;
		height: 1000px;
		top: 0;
		left: 0;
		right: 23em;
		bottom: 0;
	}

	body {
		margin: 0;
	}

	.wrapper {
		min-height: 100vh;
		_background: #ccc;
		display: flex;
		flex-direction: column;
	}

	.header,
	.footer {
		height: 50px;
		background: #666;
		color: #fff;
	}

	.content {
		display: flex;
		flex: 1;
		background: #999;
		color: #000;
	}

	.columns {
		display: flex;
		flex: 1;
	}



	.main {
		flex: 1;
		order: 2;
		background: #eee;
	}

	.sidebar-first {
		width: 20%;
		background: #ccc;
		order: 1;
	}

	.sidebar-second {
		width: 20%;
		order: 3;
		background: #ddd;
	}

	.box {
		display: block;
		background: #fff;
		border-radius: var(--radius);
		box-shadow: var(--shadow);
		padding: var(--small);
		transition: box-shadow var(--transition);
		font: 100%/1.5 Helvtica Neue, Helvetica, sans-serif;
		margin: 5px;
	}

	table {
		width: 100%;
		text-align: left;
		border-collapse: collapse;
		background: #fff;
		color: var(--gray-800);
	}

	table input[type=text] {
		padding: 0 var(--small);
	}

	tr {
		border-bottom: thin solid var(--gray-400);
	}

	tr:focus-within {
		background: highlight
	}

	th h3 {
		padding: 0 var(--small);
	}

	h3 {
		font-weight: 500;
		line-height: 1;
		font-size: 1em;
		margin-bottom: var(--radius);
	}

	.value-column input {
		font: 100%/1.4 monospace
	}



	.box header {
		font-size: 1.2em;
		margin: 0;
		font-weight: 400;
	}

	table input {
		border: 0;
	}

	canvas {
		width: 100%;
		min-height: 400px;
		border: solid 2px red;
	}
</style>

<body>
	<div class="wrapper">
		<header class="header">Header: Fixed height</header>
		<section class="content">
			<div class="columns">
				<main class="box main">
					<div id="chart_container"></div>
				</main>
				<aside class="box sidebar-first">Sidebar first: Fixed width</aside>
				<aside class="box sidebar-second">
					<header>Data</header>
					<div class="data-table">
						<table>
							<thead>
								<tr>
									<th class="name-column">
										<h3>Name</h3>
									</th>
									<th class="value-column">
										<h3>Value</h3>
									</th>
									<th></th>
								</tr>
							</thead>
							<tbody>
								<tr id="row-7xkan8q5">
									<td class="name-column"><input type="text" value="First Name"></td>
									<td class="value-column"><input type="text" value="Joe"></td>
								</tr>
								<tr id="row-7xkan8q5">
									<td class="name-column"><input type="text" value="Last Name"></td>
									<td class="value-column"><input type="text" value="Smith"></td>
								</tr>

							</tbody>
						</table>
					</div>
				</aside>
			</div>
		</section>
		<footer class="footer">Footer: Fixed height</footer>
	</div>
</body>

<script>
	window.onload = function () {

		function log(msg) {
			if (true) {
				console.log(msg);
			}
		}


		// =============================================================
		//                          MChartModel
		// =============================================================
		function MChartModel({ nodes, links }) {
			var m = this;
			m.nodes = nodes;
			m.links = links;
		}
		MChartModel.prototype.addNode = function (node) {
			nodes.push(node);
			//this.update();
		};
		MChartModel.prototype.getNodes = function (node) {
			return nodes;
		};


		// =============================================================
		//                          Node
		// =============================================================
		function Node() {
			this.x = 0;
			this.y = 0;
			this.radius = 20;
			this.offset = { x: 0, y: 0 };
			this.type = "";
			this.name = "";
		}


		// =============================================================
		//                          Link
		// =============================================================
		function Link(source, target) {
			this.source = source;
			this.target = target;
			this.start_X = this.source.x;
			this.start_Y = this.source.y;
			this.end_X = this.target.x;
			this.end_Y = this.target.y;
		}



		// =============================================================
		//                          Graph
		// =============================================================
		function Graph() {
			this.nodes = [];
			this.edges = [];

		}
		Graph.prototype.addNode = function (node) {
			this.nodes.push(node);
		};
		Graph.prototype.getNodes = function (node) {
			return this.nodes;
		};

		// =============================================================
		//                          MChartView
		// =============================================================
		function MChartView({ mcanvas }) {
			console.log("MChartView()");
			this.mcanvas = mcanvas;
			this.ctx = mcanvas.getContext();
			console.log(this.mcanvas);
			console.log("getWidth = " + this.getWidth());
			console.log("getHeight = " + this.getHeight());
			this.background_color = "#FFFFFF";//"#F5F5F5";

			this.color_ring_isActivated = "#3b6978";
			this.color_ring_isBelowMouse = "#84a9ac";

		}
		MChartView.prototype.getContext = function () {
			return this.ctx;
		};
		MChartView.prototype.getHeight = function () {
			return this.mcanvas.getHeight();
		};
		MChartView.prototype.getWidth = function () {
			return this.mcanvas.getWidth();
		};
		MChartView.prototype.addEventListener = function (type, listener) {
			this.mcanvas.addEventListener(type, listener);
		};
		MChartView.prototype.clear = function () {
			this.ctx.clearRect(0, 0, this.getWidth(), this.getHeight());
		};
		MChartView.prototype.drawBorder = function () {
			log("MChartView .drawBorder");
			//this.mcanvas.drawBorder(this.background_color);
		}

		MChartView.prototype.renderLink = function (link) {
			log("renderLink ");
			log(link);

			var strokeStyle = "grey";
			var lineWidth = "1";
			this.mcanvas.drawLine(link.source.x, link.source.y, link.target.x, link.target.y, strokeStyle, lineWidth);

		}

		MChartView.prototype.renderNode = function (node) {
			log("MChartView .renderNode: " + node.name);

			if (node.type == "person") {
				//console.log("it's  a person");
			}
			else if (node.type == "case") {
				//console.log("it's  a person");
			}

			var font = "12px Arial"
			var text_color = "#333";
			this.mcanvas.drawPoint(node.x, node.y, node.radius, node.name);
			//this.mcanvas.drawTextBG(node.name, node.x, node.y, font, 0, this.background_color);

			var padding_node_title = 0;
			var circle_width = 2 * node.radius;
			var maxLineWidth = 1.5 * circle_width;
			// CENTER TEXT
			var y = node.y + node.radius + padding_node_title;
			this.mcanvas.drawText(node.x, y, node.name, font, text_color, maxLineWidth, ",");


			if (node.isClicked) {
				this.mcanvas.drawRing(node.x, node.y, node.radius + 2, this.color_ring_isActivated);
			}
			else if (node.isBelowMouse) {
				this.mcanvas.drawRing(node.x, node.y, node.radius + 2, this.color_ring_isBelowMouse);
			}
		}



		// =============================================================
		//                          MRadialLayout
		// =============================================================
		function MRadialLayout({ graph, width, height }) {
		//	this.nodes = graph.nodes;
			this.width = width;
			this.height = height;
			console.log("MRadialLayout()");
			console.log("width = " + width);
			console.log("height = " + height);
			console.log("this.nodes = ");
		//	console.log(this.nodes);
			//var center = mcanvas.getCenter();

		}
		MRadialLayout.prototype.layout = function () {
			//console.log("MRadialLayout : layout");

			if (! this.nodes) {
				console.error("MRadialLayout : can't run on an empty graph.");
				return;

			}
			if (this.nodes.length == 0) {
				return;
			}
			// Center the root
			var root = this.nodes[0];
			root.x = this.width / 2;
			root.y = this.height / 2;

			// replace by layout with Compass
			for (var i = 1; i < this.nodes.length; i++) {
				var node = this.nodes[i];
				node.x = root.x + (i * 50);
				node.y = root.y + (i * 50);
			}
		};


		// =============================================================
		//                          LinkAnalysis
		// =============================================================
		function LinkAnalysis(chart_container) {

			var NODE_GROUP_CLASS = "nodeXXX";
			var image_width = 35;
			var image_height = image_width;
			var node_width = image_width;
			var node_height = image_width;

			var icon_width = 40;
			var icon_heigth = 40;

			// COLORS ???

			//this.graph = new Graph(); //model
			var me = this;
			var thisLinkAnalysis = this;

			me.idct = 0;
			me.nodesLevel = [];
			me.nodes = [];
			me.links = [];

			log(" MChartController() => this.nodes");
			log(this.nodes);



			// the imgs[] array now holds fully loaded images
			this.mcanvas = new MCanvas({ container: chart_container });
			this.view = new MChartView({ mcanvas: this.mcanvas });
			this.model = new MChartModel({ nodes: me.nodes, links: me.links });
			controller = this;

			this.nodes = this.model.nodes;
			this.current_node = null;
			this.links = this.model.links;

			this.context = this.view.getContext();
			var width = this.view.getWidth();
			//			this.addEventListeners();
			this.layout = new MRadialLayout({ model: this.model, width: this.view.getWidth(), height: this.view.getHeight() });
			this.layout.layout();



			/////////////
			console.log("getComputedStyle");
			console.log("----------------");

			const style = document.defaultView.getComputedStyle(this.mcanvas.canvas, null);
			this.stylePaddingLeft = parseInt(style['paddingLeft'], 10);
			this.stylePaddingTop = parseInt(style['paddingTop'], 10);
			this.styleBorderLeft = parseInt(style['borderLeftWidth'], 10);
			this.styleBorderTop = parseInt(style['borderTopWidth'], 10);
			// Some pages have fixed-position bars (like the stumbleupon bar) at the top or left of the page
			// They will mess up mouse coordinates and this fixes that
			var html = document.body.parentNode;
			this.htmlTop = html.offsetTop;
			this.htmlLeft = html.offsetLeft;
			console.log(" this.htmlTop: " + this.htmlTop);
			console.log(" this.htmlTop: " + this.htmlTop);
			//////////////


			function handleMouseDown(event, callback) {
				console.log("in handleMouseDown");
				event.preventDefault();

				var mouse = me.getMouse(event);
				console.log("mouse @ " + mouse.x + "," + mouse.y);


				for (var i = 0; i < controller.nodes.length; i++) {
					var node = me.nodes[i];

					if (pointInCircle(mouse.x, mouse.y, node)) {

						//	if (pointInCircle(event.clientX, event.clientY, node)) {
						console.log("node " + node.name + " isClicked");
						node.isClicked = true;

						// Keep track of where in the object we clicked
						// so we can move it smoothly (see mousemove)
						me.selection = node;
						me.dragoffx = mouse.x - node.x;
						me.dragoffy = mouse.y - node.y;
						me.dragging = true;
						me.valid = false;

						// @TODO: Add Callback to listerer(node);
						return;
					}
					else {
						node.isClicked = false;
					}
				}
				controller.render();
			}

			function handleMouseMove(event) {
				event.stopPropagation();
				var mouse = me.getMouse(event);

				// Highlight Node when mouse over
				for (var i = 0; i < controller.nodes.length; i++) {
					var node = controller.nodes[i];
					if (pointInCircle(mouse.x, mouse.y, node)) {
						//					if (pointInCircle(event.clientX, event.clientY, node)) {
						console.log("node " + node.name + " isBelowMouse");
						node.isBelowMouse = true;
					}
					else {
						node.isBelowMouse = false;
					}
				}

				if (me.dragging) {
					// We don't want to drag the object by its top-left corner,
					// we want to drag from where we clicked.
					// Thats why we saved the offset and use it here
					me.selection.x = mouse.x - me.dragoffx;
					me.selection.y = mouse.y - me.dragoffy;
					me.valid = false; // Something's dragging so we must redraw
				}
				controller.render();
			}

			function handleMouseUp(event) {
				console.log(" handleMouse UP");
				me.dragging = false;

				/*
				if (controller.current_node != null) {
					controller.current_node.isClicked = true;
					//controller.current_node = null;
				}
				else {
					controller.current_node.isClicked = false;
					controller.current_node = null;
				}
*/
				if (controller.current_node) {
					console.log("controller.current_node " + controller.current_node.name + " isClicked");
					me.nodeClickHandler(controller.current_node);
				}
				controller.render();

			}

			this.view.addEventListener("mouseup", handleMouseUp, false);
			this.view.addEventListener("mousemove", handleMouseMove, false);
			this.view.addEventListener("mousedown", function (event) {
				console.log("in addEventListener");
				console.log(this.nodeClickHandler);
				handleMouseDown(event, this.nodeClickHandler);
			});

			this.render = function () {
				console.log("LinkAnalysis.render");
				//this.controller.render();

				log("MChartController .render");
				this.view.clear();
				this.view.drawBorder();


				log("controller.links.length = " + controller.links.length);
				for (var i = 0; i < controller.links.length; i++) {
					var link = controller.links[i];
					this.view.renderLink(link);
				}

				log("controller.nodes.length");
				log(controller.nodes);
				for (var i = 0; i < controller.nodes.length; i++) {
					var node = controller.nodes[i];
					this.view.renderNode(node);
					//node.draw(this.context);
				}
			}
		}

		LinkAnalysis.prototype = {


			addNode: function (newNodeObject, parentNodeObject) {
				var me = this;
				console.log("LinkAnalysis addNode: " + newNodeObject);
				var numNodes = me.nodes.length;

				newNode = new Node();
				//newNode.x = 0;
				//newNode.y = 0;
				newNode.id = numNodes;
				newNode.name = newNodeObject.name;
				newNode.parent = parentNodeObject;
				newNode.level = this.getNodeLevel(newNodeObject);
				console.log("  - nodeLevel " + newNode.level);

				var nodesAtThisLvel = me.nodesLevel[newNode.level];
				if (nodesAtThisLvel == null) {
					me.nodesLevel[newNode.level] = [newNode];
				}
				else {
					me.nodesLevel[newNode.level].push(newNode);
				}

				console.log("  - nodesAtThisLevel " + me.nodesLevel[newNode.level].length);

				if (parentNodeObject.children == null) parentNodeObject.children = [];
				parentNodeObject.children.push(newNode);

				var link = new Link(newNode, parentNodeObject);
				me.links.push(link);
				me.nodes.push(newNode);

				var root_node = me.nodesLevel[0][0];
				this.setXY(root_node);
				me.updateGraph();
			},


			setRootNode: function (node) {
				console.log("TODO: setRootNode canvas size");
				var me = this;
				var center = this.mcanvas.getCenter();
				console.log("CENTER: " + center.x + "/" + center.y);

				node.x = center.x;
				node.y = center.y;
				node.id = 0;
				node.level = 0;


				me.nodes.push(node);
				me.nodesLevel[0] = [node];
				//me.updateGraph();

				console.log("setRootNode: size = ");
				console.log(node);
			},

			setNodeClickHandler: function (nodeClickHandler) {
				this.nodeClickHandler = nodeClickHandler;
				console.log("nodeClickHandler=" + this.nodeClickHandler);
			},

			// Creates an object with x and y defined,
			// set to the mouse position relative to the state's canvas
			// If you wanna be super-correct this can be tricky,
			// we have to worry about padding and borders

			getMouse: function (e) {
				var element = this.mcanvas.canvas, offsetX = 0, offsetY = 0, mx, my;

				// Compute the total offset
				if (element.offsetParent !== undefined) {
					do {
						offsetX += element.offsetLeft;
						offsetY += element.offsetTop;
					} while (element = element.offsetParent);
				}

				// Add padding and border style widths to offset
				// Also add the offsets in case there's a position:fixed bar
				offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
				offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;

				mx = e.pageX - offsetX;
				my = e.pageY - offsetY;

				//mx = e.pageX ;
				//my = e.pageY ;

				// We return a simple javascript object (a hash) with x and y defined
				return { x: mx, y: my };
			},

			updateGraph: function () {
				this.render();
			}
		}


		LinkAnalysis.prototype.getNodeLevel = function (node) {
			var level = 0;
			var parent = node.parent;
			while (parent) {
				level++;
				parent = parent.parent;
			}
			return level;
		}

		LinkAnalysis.prototype.setXY = function (node) {
			//			var me = this;

			console.log("  setXY " + node.name);
			if (node.children == null) return;

			console.log(node);
			var num_children = node.children.length;
			console.log("  children: " + num_children);

			var width = 100;
			var parentX = node.x;
			var parentY = node.y;

			for (var i = 0; i < num_children; i++) {

				var child_node = node.children[i];
				var radius = 200 / (node.level + 1);

				var angle = (i / (num_children / 2)) * (Math.PI) // Calculate the angle at which the element will be placed.
				// For a semicircle, we would use (i / numNodes) * Math.PI.
				var x = (radius * Math.cos(angle)); // Calculate the x position of the element.
				var y = -(radius * Math.sin(angle)); // Calculate the y position of the element.

				// ih which quadrant is the point located?

				child_node.x = x + parentX;
				child_node.y = y + parentY;


				console.log("  node " + child_node.name
					+ " Level=" + node.level
					+ " x=" + x
					+ " y=" + y
					+ " radius=" + radius
					+ " parent (x=" + parentX + ", y=" + parentY + ")"
					+ " angle=" + angle);
				this.setXY(child_node);

			}
		}

		LinkAnalysis.prototype.setIconByNodeType = function (IconByNodeType) {
			this.IconByNodeType = IconByNodeType;
		}


		LinkAnalysis.prototype.draw____ = function (data, options) {
			console.log("LinkAnalysis draw");
			this.model = new MChartModel({ nodes: data });
			this.controller = new MChartController({
				model: this.model,
				view: this.view
			});
			this.render();
		};

		function Circle(x, y, radius, fill, stroke) {
			this.startingAngle = 0;
			this.endAngle = 2 * Math.PI;
			this.x = x;
			this.y = y;
			this.radius = radius;
			this.fill = fill;
			this.stroke = stroke;
			this.isClicked = false;
			this.isBelowMouse = false;
			this.offset = { x: 0, y: 0 };


			Circle.prototype.drawImage = function (context, image) {
				var icon_x = this.x - icon_width / 2; // to fit into circle
				var icon_y = this.y - icon_heigth / 2; // to fit into circle
				context.drawImage(image, icon_x, icon_y, icon_width, icon_heigth);
			}

			this.draw = function (context) {
				//console.log("Circle.draw()");
				context.beginPath();
				context.fillStyle = this.fill;

				//console.log("x=" + this.x + ", y=" + this.y + " r=" + this.radius);

				context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
				context.fill();

				// TODO
				// IconByNodeType does not exist in the class Circle
				var node_type = "case";

				var icon_element = this.IconByNodeType[node_type];
				if (icon_element) {
					var image = icon_element.image;
					if (!image) {
						console.log("=====");
						console.log(ICON_LIST[node_type]);
						console.log("=====");
					}
					this.drawImage(context, image);
				}
				else {
					console.log("IconByNodeType " + this.IconByNodeType + " does not exist in the class Circle");

				}

				//console.log("isBelowMouse: " + this.isBelowMouse);
				if (this.isClicked) {
					//this.drawRing(context, color_ring_isActivated);
					this.drawRing(context, "blue");
				}
				else if (this.isBelowMouse) {
					//this.drawRing(context, color_ring_isBelowMouse);
					this.drawRing(context, "green");
				}
			}
		}
		// =============================================================
		//                          MAIN FUNCTIONS
		// =============================================================
		var IconByNodeType = {
			"case": {
				"url": icon_case_base64
			},
			"arrest": {
				"url": icon_arrest_base64
			}
		};


		var chart_container = document.getElementById("chart_container");
		var linkAnalysis = new LinkAnalysis(chart_container);


		var main_person = { id: "p_123", name: "Eric Fox", type: "person", photo: "https://randomuser.me/api/portraits/men/22.jpg" };
		linkAnalysis.setRootNode(main_person);

		var vehicle = { name: "vehicle", "type": "vehicle" };
		linkAnalysis.addNode(vehicle, main_person);   // add a note and add an edge 

		var fugitive_case = { name: "FCS0001089", "type": "case" };
		linkAnalysis.addNode(fugitive_case, main_person);

		var node_arrest = { name: "AR-784723", type: "arrest" };
		linkAnalysis.addNode(node_arrest, main_person);

		var node_family = { name: "Family" };
		linkAnalysis.addNode(node_family, main_person);

		var node_Lisa = { "name": "FOX, Lisa", "relationship": "Wife", "age": "42", "degree_of_relationship": "0", "photo": "https://randomuser.me/api/portraits/women/33.jpg" };
		var node_Edward = { "name": "FOX, Edward", "relationship": "Son", "age": "18", "degree_of_relationship": "1", "photo": "https://randomuser.me/api/portraits/men/22.jpg" };
		var node_Cindy = { "name": "FOX, Cindy", "relationship": "Daughter", "age": "16", "degree_of_relationship": "1", "photo": "https://randomuser.me/api/portraits/women/33.jpg" };
		//var nodes_family = [node_Lisa, node_Edward, node_Cindy];
		// {"name":"PARK, Carlos","relationship":"Cousin","age":"38","degree_of_relationship":"3","photo":"https://dojopsdemo.service-now.com/c09393281bf01090f76f20252a4bcb1a.iix"}]
		linkAnalysis.addNode(node_Lisa, node_family);
		linkAnalysis.addNode(node_Edward, node_family);
		linkAnalysis.addNode(node_Cindy, node_family);


		var node_known_addresses = { name: "Known Addresses", "type": "location" };
		linkAnalysis.addNode(node_known_addresses, main_person);
		var node_place_A = { name: "808 W. Spokane Blvd., Spokane WA", "type": "address" };
		var node_place_B = { name: "188 Hunters Dr, Los Angeles CA", "type": "address" };
		var node_place_C = { name: "3256 East Market St, Los Angeles CA", "type": "address" };
		linkAnalysis.addNode(node_place_A, node_known_addresses);
		linkAnalysis.addNode(node_place_B, node_known_addresses);
		linkAnalysis.addNode(node_place_C, node_known_addresses);


		linkAnalysis.setIconByNodeType(IconByNodeType);


		function handleNodeClicked(node) {
			console.log("NODE CLICKED: " + node.name);
		}

		linkAnalysis.setNodeClickHandler(handleNodeClicked);


		var options = {};
		//	linkAnalysis.draw(graph_data, options);
		console.log(linkAnalysis);

		//@TODO  LOAD
		//loadAllImages(ICON_LIST, start);
		//
	}
</script>

</html>